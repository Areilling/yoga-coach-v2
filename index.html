<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>ğŸ§˜ æ ‘å¼è¯„ä¼° Â· 5ç§’è‡ªåŠ¨è¯„åˆ†</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.12.0/dist/tf-core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.12.0/dist/tf-converter.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.12.0/dist/tf-backend-webgl.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0/dist/pose-detection.min.js"></script>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  html,body{height:100%;background:#000;color:#fff;font-family:"PingFang SC",system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  .stage{position:relative;width:100vw;height:100vh}
  #video,#canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
  #status,#hud,#fps{position:absolute;left:0;width:100%;text-align:center;z-index:10;text-shadow:0 2px 6px rgba(0,0,0,.6)}
  #status{top:12px;color:#4fc3f7;font-size:14px}
  #hud{top:40px;color:#fff;font-size:18px;font-weight:600}
  #fps{top:68px;color:#bbb;font-size:12px}
  #overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.92);z-index:20}
  .title{font-size:22px;line-height:1.5;text-align:center}
  .subtitle{margin-top:8px;font-size:14px;color:#bbb;text-align:center;max-width:86vw}
  .controls{position:absolute;bottom:14px;left:50%;transform:translateX(-50%);display:flex;flex-wrap:wrap;gap:10px;z-index:12;justify-content:center}
  button{background:#4fc3f7;color:#fff;border:none;padding:10px 14px;border-radius:12px;font-size:14px;font-weight:600;cursor:pointer;box-shadow:0 6px 18px rgba(79,195,247,.25)}
  button.ghost{background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.18)}
  .legend{position:absolute;right:12px;bottom:70px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:8px 10px;font-size:12px;color:#ddd;z-index:11}
  .chip{position:absolute;left:12px;bottom:70px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:6px 10px;font-size:12px;color:#ddd;z-index:11}
  .tips{position:absolute;bottom:8px;width:100%;text-align:center;color:#aaa;font-size:12px}
  /* ç»“æœé¢æ¿ */
  #result{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:30;background:rgba(0,0,0,.65);backdrop-filter: blur(2px)}
  .card{max-width:560px;width:90vw;background:rgba(20,20,22,.95);border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:18px}
  .card h3{font-size:18px;margin-bottom:8px}
  .score{font-size:40px;font-weight:800;margin:6px 0 12px}
  .ok{color:#2ecc71}.bad{color:#ff6b6b}
  ul{margin:8px 0 0 18px;color:#ddd;font-size:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:14px}
  .row>button{flex:1}
</style>
</head>
<body>
<div class="stage">
  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>
  <div id="status">â³ å°±ç»ªä¸­â€¦</div>
  <div id="hud"></div>
  <div id="fps"></div>

  <div id="overlay">
    <div class="title">ğŸ§˜ æ ‘å¼è¯„ä¼° Â· è‡ªåŠ¨è¯„åˆ†</div>
    <div class="subtitle">è¯·ç«™åœ¨æ˜äº®å¤„ï¼Œå…¨èº«å…¥é•œã€‚<br>å¯åŠ¨æ–¹å¼ï¼š<b>ç«™å®š + èƒ¸å‰åˆå</b>ï¼Œä¿æŒå§¿åŠ¿ <b>5ç§’</b> è‡ªåŠ¨è¯„åˆ†ã€‚</div>
    <div style="height:16px"></div>
    <button id="startBtn">ğŸ‘‰ å¼€å¯æ‘„åƒå¤´</button>
  </div>

  <div class="controls">
    <button id="switchBtn" class="ghost">åˆ‡æ¢å‰/åæ‘„</button>
    <button id="freezeBtn" class="ghost">ç«‹å³ç»“ç®—</button>
    <button id="resetBtn" class="ghost">é‡æ–°åŠ è½½</button>
  </div>

  <div class="chip" id="peopleChip">äººæ•°ï¼š--</div>
  <div class="legend">ç»´åº¦ï¼šç›´è…¿ Â· å¼¯è…¿ Â· éª¨ç›† Â· æ‰‹ä½ Â· è„šä½ Â· ç¨³å®šåº¦</div>
  <div class="tips">å…¨æœ¬åœ°æ¨ç† Â· ä¸ä¸Šä¼ ä»»ä½•å›¾åƒ/è§†é¢‘</div>

  <!-- ç»“æœå¼¹å±‚ -->
  <div id="result">
    <div class="card">
      <h3 id="resTitle">æ ‘å¼è¯„ä¼°ç»“æœ</h3>
      <div class="score" id="resScore">--</div>
      <div id="resSummary" style="font-size:14px;color:#ccc"></div>
      <ul id="resTips"></ul>
      <div class="row">
        <button id="retryBtn" class="ghost">â†º é‡æ–°æµ‹ä¸€æ¬¡</button>
        <button id="closeBtn">å®Œæˆ</button>
      </div>
    </div>
  </div>
</div>

<script>
(async () => {
  const CFG = {
    backend: 'webgl',
    poseModelType: 'full',   // ğŸ‘ˆ å…³é”®ï¼šä½¿ç”¨ full æ¨¡å‹
    smoothing: true,
    video: { width: 640, height: 480, fps: 24 },
    HOLD_SEC: 5.0,           // ğŸ‘ˆ 5ç§’è‡ªåŠ¨è¯„åˆ†
    STRAIGHT_MIN: 165,
    BENT_MAX: 120,
    PELVIS_TILT_MAX: 20,
    PRAYER_WRIST_DIST: 60,   // åˆååˆ¤å®šæ›´å®½æ¾
  };

  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  const statusEl = document.getElementById('status');
  const hudEl = document.getElementById('hud');
  const peopleChip = document.getElementById('peopleChip');
  const resLayer = document.getElementById('result');
  const resScore = document.getElementById('resScore');
  const resSummary = document.getElementById('resSummary');
  const resTips = document.getElementById('resTips');

  let facing = 'user', stream = null, detector = null;
  let running = false, finalized = false;
  let holdStart = null;
  let lastPose = null;

  // å¯åŠ¨æ‘„åƒå¤´
  async function startCamera() {
    statusEl.textContent = 'ğŸ“· è¯·æ±‚æ‘„åƒå¤´â€¦';
    if (stream) stream.getTracks().forEach(t => t.stop());
    stream = await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: { facingMode: facing, width: CFG.video.width, height: CFG.video.height }
    });
    video.srcObject = stream;
    await video.play();
    canvas.width = video.videoWidth || CFG.video.width;
    canvas.height = video.videoHeight || CFG.video.height;
  }

  // åŠ è½½æ¨¡å‹
  async function loadModel() {
    statusEl.textContent = 'ğŸ§  åŠ è½½AIæ¨¡å‹ï¼ˆå®Œæ•´ç‰ˆï¼‰â€¦';
    await tf.setBackend(CFG.backend);
    await tf.ready();
    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.BlazePose,
      { runtime: 'tfjs', modelType: CFG.poseModelType, enableSmoothing: CFG.smoothing }
    );
  }

  // è®¡ç®—ä¸¤ç‚¹è·ç¦»
  const dist2d = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

  // åˆ¤æ–­æ˜¯å¦åŒæ‰‹åˆåï¼ˆæ‰‹è…•é è¿‘èƒ¸å‰ï¼‰
  function isPraying(kps) {
    const lw = kps[15], rw = kps[16], ls = kps[11], rs = kps[12];
    if (!lw || !rw || !ls || !rs) return false;
    const wristDist = dist2d(lw, rw);
    const chestDist = (dist2d(lw, ls) + dist2d(rw, rs)) / 2;
    return wristDist < CFG.PRAYER_WRIST_DIST && chestDist < 150;
  }

  // ç»˜åˆ¶éª¨æ¶
  function drawSkeleton(kps) {
    if (!kps) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const edges = [[11,13],[13,15],[12,14],[14,16],[11,12],[23,24],[11,23],[12,24],[23,25],[25,27],[24,26],[26,28]];
    ctx.strokeStyle = '#4fc3f7';
    ctx.lineWidth = 3;
    for (const [a, b] of edges) {
      const p = kps[a], q = kps[b];
      if (p?.score > 0.3 && q?.score > 0.3) {
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(q.x, q.y);
        ctx.stroke();
      }
    }
    ctx.fillStyle = 'red';
    for (const kp of kps) {
      if (kp?.score > 0.3) {
        ctx.beginPath();
        ctx.arc(kp.x, kp.y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // è®¡ç®—è§’åº¦
  function angleDeg(a, b, c) {
    if (!a || !b || !c) return null;
    const r = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
    let d = Math.abs(r * 180 / Math.PI);
    return d > 180 ? 360 - d : d;
  }

  // è¯„åˆ†
  function scoreTree(kps) {
    const lh = kps[23], rh = kps[24], lk = kps[25], rk = kps[26], la = kps[27], ra = kps[28];
    if (!lh || !rh || !lk || !rk || !la || !ra) return { score: 0, problems: ['å…³é”®ç‚¹ä¸è¶³'] };

    const LKA = angleDeg(lh, lk, la);
    const RKA = angleDeg(rh, rk, ra);
    if (LKA === null || RKA === null) return { score: 0, problems: ['è§’åº¦è®¡ç®—å¤±è´¥'] };

    const straight = Math.max(LKA, RKA);
    const bent = Math.min(LKA, RKA);
    const pelvisTilt = Math.abs(lh.y - rh.y);

    let score = 0;
    const problems = [];

    if (straight >= CFG.STRAIGHT_MIN) score += 30; else problems.push('ç«™ç«‹è…¿ä¸å¤Ÿç›´');
    if (bent <= CFG.BENT_MAX) score += 30; else problems.push('æŠ¬è…¿è†ç›–æœªå¼¯æ›²');
    if (pelvisTilt < 15) score += 20; else problems.push('éª¨ç›†å€¾æ–œ');
    score += 20; // æ‰‹ä½å·²é€šè¿‡åˆåæ£€æµ‹ï¼Œè„šä½ç®€åŒ–å¤„ç†

    return { score: Math.min(100, Math.round(score)), problems };
  }

  // æ˜¾ç¤ºç»“æœ
  function showResult(res) {
    finalized = true;
    const s = res.score;
    resScore.textContent = `${s} åˆ†`;
    resScore.className = 'score ' + (s >= 80 ? 'ok' : (s >= 60 ? '' : 'bad'));
    resSummary.textContent = s >= 80 ? 'å§¿åŠ¿è§„èŒƒï¼Œä¿æŒè‰¯å¥½ï¼' : (s >= 60 ? 'åŸºæœ¬è¾¾æ ‡ï¼Œæ³¨æ„ç»†èŠ‚è°ƒæ•´ã€‚' : 'æœªè¾¾æ ‡ï¼Œå»ºè®®æ ¹æ®æç¤ºé€é¡¹çº æ­£ã€‚');
    resTips.innerHTML = '';
    (res.problems.length ? res.problems : ['æ— æ˜æ˜¾é—®é¢˜']).forEach(t => {
      const li = document.createElement('li');
      li.textContent = t;
      resTips.appendChild(li);
    });
    resLayer.style.display = 'flex';
  }

  // ä¸»å¾ªç¯
  async function detectLoop() {
    if (!running) return;
    const poses = await detector.estimatePoses(video);
    const numPeople = poses.length;
    peopleChip.textContent = `äººæ•°ï¼š${numPeople}`;

    if (numPeople === 0) {
      hudEl.textContent = 'æœªæ£€æµ‹åˆ°äººä½“';
      holdStart = null;
    } else {
      const pose = poses[0];
      lastPose = pose;
      drawSkeleton(pose.keypoints);

      if (pose.keypoints && isPraying(pose.keypoints)) {
        if (!holdStart) holdStart = Date.now();
        const elapsed = (Date.now() - holdStart) / 1000;
        if (elapsed >= CFG.HOLD_SEC) {
          running = false;
          const result = scoreTree(pose.keypoints);
          showResult(result);
          return;
        }
        hudEl.textContent = `âœ… åˆåæ£€æµ‹ä¸­â€¦ ${Math.ceil(CFG.HOLD_SEC - elapsed)} ç§’`;
      } else {
        holdStart = null;
        hudEl.textContent = 'è¯·ç«™å®šå¹¶åŒæ‰‹åˆå';
      }
    }
    requestAnimationFrame(detectLoop);
  }

  // åˆå§‹åŒ–
  async function init() {
    try {
      await startCamera();
      await loadModel();
      document.getElementById('overlay').style.display = 'none';
      running = true;
      statusEl.textContent = 'å‡†å¤‡å°±ç»ª';
      detectLoop();
    } catch (err) {
      console.error(err);
      statusEl.textContent = 'âŒ å¯åŠ¨å¤±è´¥ï¼š' + (err.message || 'æœªçŸ¥é”™è¯¯');
    }
  }

  // æŒ‰é’®ç»‘å®š
  document.getElementById('startBtn').addEventListener('click', init);
  document.getElementById('resetBtn').addEventListener('click', () => location.reload());
  document.getElementById('freezeBtn').addEventListener('click', () => {
    if (lastPose?.keypoints && !finalized) {
      showResult(scoreTree(lastPose.keypoints));
      running = false;
    }
  });
  document.getElementById('retryBtn').onclick = () => {
    resLayer.style.display = 'none';
    finalized = false;
    holdStart = null;
    running = true;
    detectLoop();
  };
  document.getElementById('closeBtn').onclick = () => {
    resLayer.style.display = 'none';
  };
})();
</script>
</body>
</html>
