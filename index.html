<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>ğŸ§˜ æ™ºæ…§ä½“è‚² Â· ç‘œä¼½è¯„ä¼°ï¼ˆæ ‘å¼å¼ºåŒ–ç‰ˆï¼‰</title>
  <!-- TFJS & Pose Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.12.0/dist/tf-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.12.0/dist/tf-converter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.12.0/dist/tf-backend-webgl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0/dist/pose-detection.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; color: #fff; font-family: "PingFang SC", system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .stage { position: relative; width: 100vw; height: 100vh; }
    #video, #canvas {
      position: absolute; inset: 0; width: 100%; height: 100%;
      object-fit: cover; transform: scaleX(-1); /* å‰ç½®æ‘„åƒå¤´é•œåƒï¼Œç»˜åˆ¶å±‚ä¿æŒä¸€è‡´ */
    }
    #status, #feedback, #fps {
      position: absolute; left: 0; width: 100%; text-align: center; z-index: 20; pointer-events: none;
      text-shadow: 0 2px 6px rgba(0,0,0,.6);
    }
    #status { top: 16px; color: #4fc3f7; font-size: 16px; }
    #feedback { top: 52px; color: #fff; font-size: 18px; font-weight: 600; }
    #fps { top: 84px; color: #bbb; font-size: 13px; }
    #overlay {
      position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center;
      background: rgba(0,0,0,.92); z-index: 30;
    }
    .title { text-align: center; color: #fff; font-size: 24px; line-height: 1.5; }
    .subtitle { font-size: 14px; color: #bbb; margin-top: 8px; text-align: center; }
    .controls {
      position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 10px; z-index: 25;
    }
    button {
      background: #4fc3f7; color: #fff; border: none; padding: 12px 16px; border-radius: 12px; font-size: 15px; font-weight: 600; cursor: pointer;
      box-shadow: 0 6px 18px rgba(79,195,247,.25);
    }
    button.alt { background: #2ecc71; }
    button.ghost { background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.2); }
    .tips { position: absolute; bottom: 8px; width: 100%; text-align: center; color: #aaa; font-size: 12px; }
    .legend {
      position: absolute; right: 12px; bottom: 60px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.1);
      border-radius: 10px; padding: 8px 10px; font-size: 12px; color: #ddd; z-index: 24;
    }
  </style>
</head>
<body>
  <div class="stage">
    <video id="video" playsinline muted></video>
    <canvas id="canvas"></canvas>
    <div id="status">â³ åŠ è½½ä¸­...</div>
    <div id="feedback"></div>
    <div id="fps"></div>

    <div id="overlay">
      <div class="title">ğŸ§˜ æ™ºæ…§ä½“è‚² Â· ç‘œä¼½è¯„ä¼°<br/>ï¼ˆæ ‘å¼ Â· å®æ—¶å§¿æ€ï¼‰</div>
      <div class="subtitle">è¯·åœ¨å…‰çº¿å……è¶³å¤„ï¼Œä¿æŒå…¨èº«å…¥é•œï¼›ä¼˜å…ˆä½¿ç”¨ HTTPS åŸŸåè®¿é—®ã€‚</div>
      <div style="height:16px"></div>
      <button id="startBtn">ğŸ‘‰ ç‚¹å‡»å¼€å¯æ‘„åƒå¤´</button>
      <div class="subtitle" style="margin-top:10px;">è‹¥æ— æ³•å¼€å¯ï¼Œè¯·åœ¨æµè§ˆå™¨å…è®¸â€œæ‘„åƒå¤´æƒé™â€ï¼Œæˆ–å…³é—­å…¶å®ƒå ç”¨æ‘„åƒå¤´çš„ Appã€‚</div>
    </div>

    <div class="controls">
      <button id="switchBtn" class="ghost">åˆ‡æ¢å‰/åæ‘„</button>
      <button id="resetBtn" class="ghost">é‡ç½®</button>
    </div>

    <div class="legend">åˆ¤å®šè¦ç´ ï¼šè†è§’ï¼ˆå¼¯/ç›´ï¼‰Â· é«‹è¸å‚ç›´åº¦ Â· æŠ¬è„šé«˜åº¦ï¼ˆç¦»åœ°ï¼‰</div>
    <div class="tips">å¾®ä¿¡æ‰«ç å¯ç”¨ Â· å…¨æœ¬åœ°æ¨ç† Â· ä¸ä¸Šä¼ ä»»ä½•è§†é¢‘/å›¾åƒ</div>
  </div>

<script>
(async () => {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const switchBtn = document.getElementById('switchBtn');
  const resetBtn  = document.getElementById('resetBtn');
  const statusEl = document.getElementById('status');
  const feedbackEl = document.getElementById('feedback');
  const fpsEl = document.getElementById('fps');

  let facing = 'user'; // 'user' å‰ç½®ï¼›'environment' åç½®
  let stream = null;
  let detector = null;
  let running = false;

  // â€”â€” è‡ªé€‚åº” Canvas åƒç´ æ¯”
  function fitCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = canvas.clientWidth || canvas.parentElement.clientWidth;
    const h = canvas.clientHeight || canvas.parentElement.clientHeight;
    canvas.width = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    // ä¸è§†é¢‘é•œåƒä¿æŒä¸€è‡´
    ctx.translate(canvas.clientWidth, 0);
    ctx.scale(-1, 1);
  }
  const ro = new ResizeObserver(fitCanvas);
  ro.observe(canvas);

  async function startCamera() {
    statusEl.textContent = 'ğŸ“· è¯·æ±‚æ‘„åƒå¤´...';
    if (stream) stream.getTracks().forEach(t => t.stop());
    const constraints = {
      audio: false,
      video: {
        facingMode: facing,
        width: { ideal: 1280 },
        height: { ideal: 720 },
        frameRate: { ideal: 30, max: 30 }
      }
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
  }

  async function loadModel() {
    statusEl.textContent = 'ğŸ§  åŠ è½½ AI æ¨¡å‹...';
    await tf.setBackend('webgl');
    await tf.ready();
    // é¢„çƒ­ï¼šæœ‰åŠ©äºç¬¬ä¸€æ¬¡æ£€æµ‹æ›´å¿«
    tf.engine().startScope();
    tf.tidy(() => tf.zeros([1, 224, 224, 3]));
    tf.engine().endScope();

    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.BlazePose,
      {
        runtime: 'tfjs',
        modelType: 'full',        // full å…³é”®ç‚¹æ›´é½å…¨
        enableSmoothing: true
      }
    );
  }

  // â€”â€” å·¥å…·å‡½æ•°
  function getPoint(kps, i, th=0.3) {
    const kp = kps[i];
    return (kp && (kp.score ?? kp.score > th)) ? { x: kp.x, y: kp.y, s: kp.score ?? 1 } : null;
  }
  function angleDeg(a, b, c) { // å¤¹è§’ ABC
    if (!a || !b || !c) return null;
    const r = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
    let d = Math.abs(r * 180 / Math.PI);
    return (d > 180) ? (360 - d) : d;
  }
  function dist(a, b) {
    if (!a || !b) return null;
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.hypot(dx, dy);
  }
  function vertness(a, b) { // å‚ç›´åº¦ï¼ˆ0 å®Œç¾å‚ç›´ï¼›è¶Šå¤§è¶Šåï¼‰
    if (!a || !b) return null;
    const dx = Math.abs(a.x - b.x), dy = Math.abs(a.y - b.y) + 1e-6;
    return dx / dy;
  }
  // æŒ‡æ ‡å¹³æ»‘ï¼ˆæŒ‡æ•°æ»‘åŠ¨å¹³å‡ï¼‰
  const smooth = (() => {
    const mem = new Map();
    return (key, val, alpha=0.25) => {
      if (val == null) return null;
      const last = mem.get(key);
      const now = (last == null) ? val : (alpha*val + (1-alpha)*last);
      mem.set(key, now);
      return now;
    };
  })();

  // â€”â€” ç»˜åˆ¶
  function drawPose(kps) {
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
    if (!kps?.length) return;
    // ç”»éª¨æ¶è¿æ¥ï¼ˆä½¿ç”¨å¸¸è§è¿çº¿ï¼‰
    const edges = [
      [11,13],[13,15], [12,14],[14,16],
      [11,12], [23,24],
      [11,23],[12,24],
      [23,25],[25,27], [24,26],[26,28],
      [27,29],[29,31], [28,30],[30,32]
    ];
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(79,195,247,.9)';
    ctx.fillStyle = '#fff';

    // çº¿
    ctx.beginPath();
    for (const [a,b] of edges) {
      const p = kps[a], q = kps[b];
      if (p?.score > .3 && q?.score > .3) {
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(q.x, q.y);
      }
    }
    ctx.stroke();

    // ç‚¹
    for (const p of kps) {
      if (p?.score > .3) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // â€”â€” æ ‘å¼åˆ¤å®šï¼ˆé²æ£’ç‰ˆï¼‰
  function evaluateTreePose(kps) {
    const L_HIP=23, R_HIP=24, L_KNEE=25, R_KNEE=26, L_ANK=27, R_ANK=28;
    const leftHip  = getPoint(kps, L_HIP), rightHip = getPoint(kps, R_HIP);
    const leftKnee = getPoint(kps, L_KNEE), rightKnee= getPoint(kps, R_KNEE);
    const leftAnk  = getPoint(kps, L_ANK),  rightAnk = getPoint(kps, R_ANK);

    if (!leftHip || !rightHip || !leftKnee || !rightKnee) {
      return { ok:false, msg:'è¯·ä¿æŒå…¨èº«å…¥é•œï¼ˆå«é«‹/è†/è¸ï¼‰' };
    }

    const lk = angleDeg(leftHip, leftKnee, leftAnk);
    const rk = angleDeg(rightHip, rightKnee, rightAnk);

    // è†è§’é˜ˆå€¼
    const STRAIGHT = 160, BENT = 120;

    // é«‹-è¸å‚ç›´åº¦ï¼ˆç«™ç«‹è…¿è¦è¶³å¤Ÿå‚ç›´ï¼‰
    const vertLeft  = vertness(leftHip, leftAnk);
    const vertRight = vertness(rightHip, rightAnk);
    // ç¦»åœ°ï¼šæŠ¬èµ·è„šçš„è¸ç›¸å¯¹ç«™ç«‹è„šçš„é«˜åº¦å·®ï¼ˆy è¶Šå°è¶Šé«˜ï¼›ç”»é¢åæ ‡ y å‘ä¸‹ï¼‰
    const footDeltaY = leftAnk && rightAnk ? Math.abs(leftAnk.y - rightAnk.y) : null;

    // å¹³æ»‘
    const lkS = smooth('lk', lk), rkS = smooth('rk', rk);
    const vLS = smooth('vL', vertLeft), vRS = smooth('vR', vertRight);
    const fdS = smooth('fd', footDeltaY);

    // åˆ¤å®šä¸¤ç§æƒ…å†µï¼ˆå·¦ç«™/å³ç«™ï¼‰
    const leftStand =
      (lkS !== null && rkS !== null && lkS > STRAIGHT && rkS < BENT) &&
      (vLS !== null && vLS < 0.25); // å‚ç›´åº¦è¶Šå°è¶Šå¥½

    const rightStand =
      (lkS !== null && rkS !== null && rkS > STRAIGHT && lkS < BENT) &&
      (vRS !== null && vRS < 0.25);

    // é¢å¤–æç¤ºï¼šè„šè·Ÿé«˜åº¦ï¼ˆç¦»åœ°ï¼‰
    let footCue = '';
    if (fdS !== null && fdS < 18) { // åƒç´ é˜ˆå€¼ï¼Œéšåˆ†è¾¨ç‡å¤§è‡´å¯ç”¨
      footCue = 'Â· æŠ¬èµ·è„šæ›´é«˜ä¸€äº›';
    }

    if (leftStand || rightStand) {
      return { ok:true, msg:`âœ… å•è…¿å¹³è¡¡ç¨³å®š ${footCue}`.trim() };
    }
    // ç»†åŒ–åé¦ˆ
    const tips = [];
    if (lkS !== null && rkS !== null) {
      if (lkS <= STRAIGHT && rkS <= STRAIGHT) tips.push('å¼¯æ›²ä¸€ä¾§è†ç›–');
      if (lkS >= BENT && rkS >= BENT) tips.push('ä¿æŒä¸€ä¾§è†ç›–ä¼¸ç›´');
    }
    if ((vLS !== null && vLS >= 0.25) || (vRS !== null && vRS >= 0.25)) {
      tips.push('ç«™ç«‹è…¿ä¿æŒå‚ç›´ï¼ˆé«‹-è¸è¿çº¿æ›´ç«–ç›´ï¼‰');
    }
    if (fdS !== null && fdS < 18) tips.push('æŠ¬èµ·è„šæ›´é«˜ä¸€äº›');

    return { ok:false, msg: tips.length ? ('è¯·å°è¯•æ ‘å¼ï¼š' + tips.join(' Â· ')) : 'è¯·å°è¯•æ ‘å¼ï¼ˆå•è…¿ç«™ç«‹ï¼‰' };
  }

  // â€”â€” æ£€æµ‹å¾ªç¯
  let lastTS = performance.now(), frameCnt = 0, lastFPS = 0;
  const SKIP = 0; // å¯æ”¹ä¸º 1/2 åšæŠ½å¸§
  let skipCnt = 0;

  async function loop() {
    if (!running) return;
    try {
      if (skipCnt < SKIP) { skipCnt++; requestAnimationFrame(loop); return; }
      skipCnt = 0;

      const t0 = performance.now();
      const poses = await detector.estimatePoses(video, { flipHorizontal: false });
      const pose = poses?.[0];
      if (!pose?.keypoints?.length) {
        feedbackEl.textContent = 'æœªæ£€æµ‹åˆ°äººä½“ï¼Œè¯·å¯¹å‡†é•œå¤´å¹¶ä¿æŒå…¨èº«å…¥é•œ';
        drawPose([]);
      } else {
        drawPose(pose.keypoints);
        const res = evaluateTreePose(pose.keypoints);
        feedbackEl.textContent = res.msg || '';
      }

      // FPS
      frameCnt++;
      const now = performance.now();
      if (now - lastTS >= 1000) {
        lastFPS = frameCnt; frameCnt = 0; lastTS = now;
      }
      const size = video.videoWidth + 'Ã—' + video.videoHeight;
      fpsEl.textContent = `FPS: ${lastFPS} Â· åˆ†è¾¨ç‡ ${size}`;

      // åŠ¨æ€æç¤º
      statusEl.textContent = 'âœ… æ­£åœ¨è¯„ä¼°â€¦';
    } catch (e) {
      console.error(e);
      feedbackEl.textContent = 'âŒ æ£€æµ‹å¼‚å¸¸ï¼Œç‚¹å‡»â€œé‡ç½®â€å†è¯•';
      statusEl.textContent = 'âŒ å‡ºé”™';
    }
    requestAnimationFrame(loop);
  }

  // â€”â€” äº‹ä»¶
  startBtn.addEventListener('click', async () => {
    try {
      await startCamera();
      overlay.style.display = 'none';
      fitCanvas();
      await loadModel();
      running = true;
      statusEl.textContent = 'âœ… å‡†å¤‡å°±ç»ªï¼è¯·åšæ ‘å¼â€¦';
      loop();
    } catch (err) {
      console.error(err);
      statusEl.textContent = 'âŒ å¯åŠ¨å¤±è´¥';
      feedbackEl.innerHTML = `<button onclick="location.reload()" style="background:#ff6b6b;color:white;border:none;padding:10px 20px;border-radius:10px;">é‡è¯•</button>`;
      overlay.style.display = '';
    }
  });

  switchBtn.addEventListener('click', async () => {
    facing = (facing === 'user') ? 'environment' : 'user';
    try {
      await startCamera();
    } catch (e) {
      console.error(e);
      feedbackEl.textContent = 'åˆ‡æ¢å¤±è´¥ï¼šè¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™';
    }
  });

  resetBtn.addEventListener('click', () => {
    location.reload();
  });

  // æƒé™æ£€æµ‹å‹å¥½æç¤º
  if (!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)) {
    statusEl.textContent = 'âŒ å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è°ƒç”¨';
    startBtn.disabled = true;
  } else {
    statusEl.textContent = 'â³ å°±ç»ªä¸­â€¦';
  }
})();
</script>
</body>
</html>
