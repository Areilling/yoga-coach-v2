<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>ğŸ§˜ æ™ºæ…§ä½“è‚² Â· ç‘œä¼½è¯„ä¼°ï¼ˆè°ƒè¯•ç‰ˆï¼‰</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.12.0/dist/tf-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.12.0/dist/tf-converter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.12.0/dist/tf-backend-webgl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0/dist/pose-detection.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: "PingFang SC", sans-serif;
      background: #000;
      color: white;
      overflow: hidden;
      touch-action: none;
    }
    #video {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      transform: scaleX(-1);
      display: none;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 5;
      display: none;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.95);
      z-index: 10;
    }
    #startBtn {
      background: #4fc3f7;
      color: white;
      border: none;
      padding: 16px 32px;
      border-radius: 12px;
      font-size: 20px;
      cursor: pointer;
      margin-top: 20px;
      font-weight: bold;
    }
    .instructions {
      position: absolute;
      bottom: 20px;
      text-align: center;
      font-size: 14px;
      color: #aaa;
      width: 100%;
    }
    #debug {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #ffcc00;
      font-size: 14px;
      z-index: 20;
      background: rgba(0,0,0,0.6);
      padding: 5px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>
  <div id="debug">ç­‰å¾…å¯åŠ¨...</div>
  
  <div id="overlay">
    <div style="text-align: center; color: white; font-size: 24px; max-width: 80%;">
      ğŸ§˜ æ™ºæ…§ä½“è‚² Â· ç‘œä¼½è¯„ä¼°<br>
      <span style="font-size: 16px; color: #bbb; margin-top: 10px; display: block;">
        è¯·åœ¨å…‰çº¿å……è¶³å¤„ä½¿ç”¨
      </span>
    </div>
    <button id="startBtn">ğŸ‘‰ ç‚¹å‡»å¼€å§‹æ‘„åƒå¤´</button>
  </div>
  <div class="instructions">å¾®ä¿¡æ‰«ç ä½¿ç”¨ Â· æ•°æ®ä»…åœ¨æœ¬åœ°å¤„ç†</div>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const debugEl = document.getElementById('debug');

    startBtn.addEventListener('click', async () => {
      try {
        debugEl.textContent = 'æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´...';
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width: 640, height: 480 },
          audio: false
        });

        video.srcObject = stream;
        video.style.display = 'block';
        canvas.style.display = 'block';
        overlay.style.display = 'none';
        await video.play();

        // è®¾ç½® canvas å°ºå¯¸
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        debugEl.textContent = 'åŠ è½½AIæ¨¡å‹...';
        await tf.setBackend('webgl');
        const detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.BlazePose,
          { runtime: 'tfjs', modelType: 'lite' }
        );
        debugEl.textContent = 'âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼';

        const feedback = document.createElement('div');
        feedback.id = 'feedback';
        feedback.style.cssText = 'position:absolute;top:60px;width:100%;text-align:center;color:white;font-size:20px;z-index:20;';
        document.body.appendChild(feedback);

        const detect = async () => {
          const poses = await detector.estimatePoses(video);
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          if (poses.length > 0 && poses[0].keypoints) {
            debugEl.textContent = `âœ… æ£€æµ‹åˆ° ${poses.length} äºº`;
            drawKeypoints(poses[0].keypoints, ctx);
            evaluatePose(poses[0].keypoints, feedback);
          } else {
            debugEl.textContent = 'âš ï¸ æœªæ£€æµ‹åˆ°äººä½“';
            feedback.textContent = 'è¯·å¯¹å‡†é•œå¤´ï¼Œå…¨èº«å…¥é•œ';
          }
          requestAnimationFrame(detect);
        };
        detect();
      } catch (err) {
        console.error(err);
        debugEl.textContent = 'âŒ å¯åŠ¨å¤±è´¥: ' + (err.message || 'æœªçŸ¥é”™è¯¯');
        overlay.innerHTML = `<div style="color:#ff6b6b;font-size:18px;text-align:center;">
          å¯åŠ¨å¤±è´¥<br>
          <button id="retryBtn" style="margin-top:15px;background:#ff6b6b;color:white;border:none;padding:10px 20px;border-radius:8px;">
            é‡è¯•
          </button>
        </div>`;
        document.getElementById('retryBtn').onclick = () => location.reload();
      }
    });

    function drawKeypoints(keypoints, ctx) {
      for (const keypoint of keypoints) {
        if (keypoint.score > 0.3) {
          ctx.beginPath();
          ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
          ctx.fillStyle = 'red';
          ctx.fill();
        }
      }
    }

    function calculateAngle(a, b, c) {
      if (!a || !b || !c) return 0;
      const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
      let angle = Math.abs(radians * 180 / Math.PI);
      return angle > 180 ? 360 - angle : angle;
    }

    function getPoint(keypoints, index) {
      return keypoints[index] ? { x: keypoints[index].x, y: keypoints[index].y } : null;
    }

    function evaluatePose(keypoints, feedbackEl) {
      const leftHip = getPoint(keypoints, 23);
      const rightHip = getPoint(keypoints, 24);
      const leftKnee = getPoint(keypoints, 25);
      const rightKnee = getPoint(keypoints, 26);
      const leftAnkle = getPoint(keypoints, 27);
      const rightAnkle = getPoint(keypoints, 28);
      const leftShoulder = getPoint(keypoints, 11);
      const rightShoulder = getPoint(keypoints, 12);

      if (!leftHip || !rightHip || !leftKnee || !rightKnee) return;

      const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
      const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);

      if ((leftKneeAngle < 120 && rightKneeAngle > 160) || (rightKneeAngle < 120 && leftKneeAngle > 160)) {
        feedbackEl.innerHTML = 'âœ… å•è…¿å¹³è¡¡<br>âœ… éª¨ç›†ç¨³å®š';
        return;
      }

      if (leftShoulder && rightShoulder) {
        const leftArmAngle = calculateAngle(getPoint(keypoints,15), leftShoulder, leftHip);
        const rightArmAngle = calculateAngle(getPoint(keypoints,16), rightShoulder, rightHip);
        if (leftArmAngle > 120 && rightArmAngle > 120) {
          feedbackEl.innerHTML = 'âœ… æ‰‹è‡‚ä¼¸å±•<br>âœ… è„ŠæŸ±å»¶å±•';
          return;
        }
      }

      feedbackEl.textContent = 'è¯·å°è¯•æ ‘å¼æˆ–ä¸‹çŠ¬å¼';
    }
  </script>
</body>
</html>
